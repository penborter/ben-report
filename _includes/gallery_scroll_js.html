<script type="text/javascript">

// Inject the opacity CSS - not needed if no JS
const style = document.createElement('style');
style.textContent = `
  .image-wrapper {
    transition: opacity 0.3s ease;
  }
  .image-wrapper.dimmed {
    opacity: 0.25;
  }
`;
document.head.appendChild(style);

document.addEventListener('DOMContentLoaded', function() {
  const gallery = document.querySelector('.horizontal-gallery-wrapper');
  const images = document.querySelectorAll('.horizontal-gallery-wrapper > *');
  let currentIndex = 0;
  let isScrolling = false;
  let hasScrolledOnce = false;
  let previousIndex = 0;
  let lastProgrammaticScroll = 0;

  function updateImageStates() {
    // Reset all images
    images.forEach(img => img.classList.add('dimmed'));
    // Highlight current image
    images[currentIndex].classList.remove('dimmed');
  }

  function scrollToImage(index) {
    if (index < 0) {
      index = images.length - 1;
    } else if (index >= images.length) {
      index = 0;
    }

    previousIndex = currentIndex;

    if (index === 0 && previousIndex !== 0) {
      hasScrolledOnce = false; // only reset if we navigated back to 0
    }
    
    currentIndex = index;
    const targetImage = images[currentIndex];
    
    const galleryRect = gallery.getBoundingClientRect();
    const imageRect = targetImage.getBoundingClientRect();
    const scrollOffset = (imageRect.left + gallery.scrollLeft) - (galleryRect.width / 2) + (imageRect.width / 2);
    
    isScrolling = true;
    
    gallery.scrollTo({
      left: scrollOffset,
      behavior: 'smooth'
    });

    updateImageStates();
    lastProgrammaticScroll = Date.now();
    
    setTimeout(() => {
      isScrolling = false;
      updateImageStates();
      lastProgrammaticScroll = Date.now();
    }, 350);
  }

  function handleKeyPress(event) {
    if (event.key === 'ArrowLeft') {
      event.preventDefault();
      if (currentIndex === 1) {
        hasScrolledOnce = false; // reset when going back to gallery-meta
      }
      scrollToImage(currentIndex - 1);
    } else if (event.key === 'ArrowRight') {
      event.preventDefault();
      if (!hasScrolledOnce && currentIndex === 0) {
        scrollToImage(1);
        hasScrolledOnce = true;
      } else {
        scrollToImage(currentIndex + 1);
      }
    }
  }

  // Initialize the dimming state
  updateImageStates();

  // Add keyboard event listener
  document.addEventListener('keydown', handleKeyPress);

  // Optional: Update dimming when scrolling manually
  let scrollTimeout;
  gallery.addEventListener('scroll', () => {
    if (isScrolling) return;

    clearTimeout(scrollTimeout);
    scrollTimeout = setTimeout(() => {

      // Don't auto-update if we just intentionally scrolled somewhere
      if (Date.now() - lastProgrammaticScroll < 500) return;

      // Find the most centered image
      let closestImage = 0;
      let closestDistance = Infinity;
      const galleryCenter = gallery.getBoundingClientRect().left + gallery.getBoundingClientRect().width / 2;
      
      images.forEach((img, index) => {
        const rect = img.getBoundingClientRect();
        const imageCenter = rect.left + rect.width / 2;
        const distance = Math.abs(galleryCenter - imageCenter);
        
        if (distance < closestDistance) {
          closestDistance = distance;
          closestImage = index;
        }
      });

      if (closestImage !== currentIndex) {
        currentIndex = closestImage;
        updateImageStates();
      }
    }, 20); // Debounce the scroll event
  });
});
  
</script>